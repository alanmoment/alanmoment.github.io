<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2014 on Hello World!!</title>
    <link>http://localhost:1313/categories/2014/</link>
    <description>Recent content in 2014 on Hello World!!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; Copyright Alan - 2016</copyright>
    <lastBuildDate>Mon, 29 Dec 2014 17:07:01 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/2014/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>吃足苦頭的Mssql</title>
      <link>http://localhost:1313/post/database/chi_zu_ku_tou_de_mssql/</link>
      <pubDate>Mon, 29 Dec 2014 17:07:01 +0000</pubDate>
      
      <guid>http://localhost:1313/post/database/chi_zu_ku_tou_de_mssql/</guid>
      <description>&lt;p&gt;為了讓 CentOS 的 PHP 可以支援 Mssql &amp;amp; UTF-8 真是吃了不少苦頭，最終在安裝 FreeTDS 後加上設定檔終於如願以償&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim /etc/freetds.conf
[global]
        # TDS protocol version
        tds version = 8.0
        client charset = UTF-8
        charset = UTF-8
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>The bash auto build</title>
      <link>http://localhost:1313/post/os/linux/the_bash_auto_build/</link>
      <pubDate>Tue, 18 Nov 2014 00:17:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/os/linux/the_bash_auto_build/</guid>
      <description>

&lt;p&gt;發覺自己在開發上常用的小工具都沒有在整理的，每次要用就都要回想，然後再一個一個找回來覺得很煩。尤其是現在工作上要管理十幾二十台後端。常常在那邊用得不順暢，才驚覺這樣真的不行！！&lt;/p&gt;

&lt;p&gt;所以就花了點時間整理，順便用&lt;code&gt;Shell Script&lt;/code&gt;寫成auto build練習一下。&lt;/p&gt;

&lt;h3 id=&#34;git:07a84c905e0ef0099b592927e9b72990&#34;&gt;Git&lt;/h3&gt;

&lt;p&gt;在&lt;code&gt;setup.sh&lt;/code&gt;的&lt;code&gt;setup_gitconfig&lt;/code&gt;這個method主要是建立常用的&lt;code&gt;gitconfig&lt;/code&gt;檔，也區分了家中與工作兩個環境去做建立&lt;/p&gt;

&lt;h3 id=&#34;vim:07a84c905e0ef0099b592927e9b72990&#34;&gt;Vim&lt;/h3&gt;

&lt;p&gt;最近想練習&lt;code&gt;vim&lt;/code&gt;所以在網路上找了感覺不錯的&lt;code&gt;vim&lt;/code&gt;也把他納進來。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://www.intelesyscorp.com/blog/awesome-vim-configuration&#34;&gt;http://www.intelesyscorp.com/blog/awesome-vim-configuration&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;gvimrc:07a84c905e0ef0099b592927e9b72990&#34;&gt;gvimrc&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;vim&lt;/code&gt;延伸的設定檔&lt;/p&gt;

&lt;h3 id=&#34;bash-profile:07a84c905e0ef0099b592927e9b72990&#34;&gt;bash_profile&lt;/h3&gt;

&lt;p&gt;這份是常用的自定義設定檔，除了在&lt;code&gt;console&lt;/code&gt;前面顯示&lt;code&gt;git branch&lt;/code&gt;及更新時間，因為時常搞錯當前環境，所以把&lt;code&gt;hostname&lt;/code&gt;也加進來了，雖然長了一點，但是辨識度很不錯！！&lt;/p&gt;

&lt;h3 id=&#34;install:07a84c905e0ef0099b592927e9b72990&#34;&gt;Install&lt;/h3&gt;

&lt;p&gt;預設是放在 &lt;code&gt;/$HOME/bash&lt;/code&gt;，設定上非常簡單&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sh setup.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打完收工！！&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Github&lt;/code&gt;
&lt;a href=&#34;https://github.com/alanmoment/bash&#34;&gt;https://github.com/alanmoment/bash&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Laravel 首發 !!!</title>
      <link>http://localhost:1313/post/php/laravel_shou_fa/</link>
      <pubDate>Tue, 19 Aug 2014 11:11:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/php/laravel_shou_fa/</guid>
      <description>

&lt;p&gt;雖然&lt;a href=&#34;http://laravel.com/&#34;&gt;Laravel&lt;/a&gt;已經出現頗久，最近總算開始動動手了，有鑑於去年開始使用Ruby on Rails，發現說Laravel也太像了吧。據匿名的朋友說現在的Framework幾乎都是&lt;code&gt;參考&lt;/code&gt;Ruby on Rails。而這次也趁機再多用幾種工具，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nitrous.io&#34;&gt;Nitrous.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;AWS S3&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.heroku.com/&#34;&gt;Heroku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每次自己開專案都想用不同的工具，而現在的工具越來越簡單，若是不瞭解原理，那豈不是很快被淘汰了嗎?&lt;/p&gt;

&lt;h2 id=&#34;建立laravel:ff06a00f5058a348bf22bfc692f8ae74&#34;&gt;建立Laravel&lt;/h2&gt;

&lt;p&gt;現在的環境，撰寫如何建立似乎已經不怎麼高手了，因為越來越簡單，而&lt;a href=&#34;http://laravel.com/docs/quick&#34;&gt;官網&lt;/a&gt;寫的也很好。所以就不再Copy了，倒是因為要使用Framework有遇到一些&lt;code&gt;PHP module&lt;/code&gt;的問題。&lt;/p&gt;

&lt;p&gt;就以前的開發環境都會有&lt;a href=&#34;http://php.net/manual/en/book.mcrypt.php&#34;&gt;php-mcrypt&lt;/a&gt;這個模組，但這次使用的環境竟然就真的沒有，或許是版本過新、或是MIS沒有安裝。不管，反正遇到問題就是要解決了&lt;/p&gt;

&lt;p&gt;在CentOS 6.7中，使用yum找不到php-mcrypt了，必須要安裝另外的套件尋找。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo rpm -ivh http://dl.fedoraproject.org/pub/epel/beta/7/x86_64/epel-release-7-0.2.noarch.rpm
$ sudo rpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-6.rpm
$ sudo yum --enablerepo=remi install php-mcrypt.x86_64
$ sudo service httpd restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;php -m&lt;/code&gt;就可以看到&lt;code&gt;mcrypt&lt;/code&gt;模組了。&lt;/p&gt;

&lt;h2 id=&#34;使用laravel:ff06a00f5058a348bf22bfc692f8ae74&#34;&gt;使用Laravel&lt;/h2&gt;

&lt;p&gt;使用起來真的是很順手，因為幾乎跟Ruby on Rails一樣了，但畢竟不是很熟手，只記錄有用到的。&lt;/p&gt;

&lt;h3 id=&#34;routes:ff06a00f5058a348bf22bfc692f8ae74&#34;&gt;Routes&lt;/h3&gt;

&lt;p&gt;進入網站的各個位址都會經過route。&lt;/p&gt;

&lt;p&gt;/secret直接401&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Route::any(&#39;/secret&#39;, function() {
    return Response::make(&#39;Unauthorized&#39;, 401);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/form只接受post並且在之前會先檢查ip&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Route::match(
    array(&#39;POST&#39;), &#39;/form&#39;, array(&#39;before&#39; =&amp;gt; &#39;ipcheck&#39;, &#39;uses&#39; =&amp;gt; &#39;HomeController@purchase&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;filters:ff06a00f5058a348bf22bfc692f8ae74&#34;&gt;Filters&lt;/h3&gt;

&lt;p&gt;是用來過濾各種請求，有App層級也有Controller的，可用下例程式碼過濾IP。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Route::filter(&#39;ipcheck&#39;, function() {
    if (!preg_match(&amp;quot;/127\.0\.0\.1/i&amp;quot;, $_SERVER[&#39;REMOTE_ADDR&#39;]) {
        return Redirect::to(&#39;/&#39;);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;app:ff06a00f5058a348bf22bfc692f8ae74&#34;&gt;App&lt;/h3&gt;

&lt;p&gt;app/config/app.php&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;debug =&amp;gt; 是否開啓除錯&lt;/li&gt;
&lt;li&gt;url =&amp;gt; 網站預設網址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;透過一些static method也能存取其中屬性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Config::set(&#39;app.url&#39;, STATIC_HOST);
Config::get(&#39;app.url&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;database:ff06a00f5058a348bf22bfc692f8ae74&#34;&gt;Database&lt;/h3&gt;

&lt;p&gt;Database當然也有好用的ORM，而我覺得好用的程度跟Ruby有得比唷。&lt;/p&gt;

&lt;p&gt;app/config/database.php&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;default =&amp;gt; 預設的資料庫&lt;/li&gt;
&lt;li&gt;connections =&amp;gt; 資料庫連線位址、帳號、密碼&amp;hellip;等&lt;/li&gt;
&lt;li&gt;redis =&amp;gt; 好用的快取&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;透過attribute可以改變連線的資料庫、使用資料表、欄位是否使用&amp;hellip;等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class User extends Eloquent {

    protected $connection = DATABASE;

    protected $table = TABLE;

    public $timestamps = false;

    public function userinfo() {
        return $this-&amp;gt;hasOne(&#39;Userinfo&#39;);
    }

}

class Userinfo extends Eloquent {

    protected $connection = DATABASE;

    protected $table = &#39;user_info&#39;;

    public function user() {
        return $this-&amp;gt;belongsTo(&#39;User&#39;);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;當資料表有關聯，可以透過function設定關係，上例關係是User有一個Userinfo，而Userinfo也相依於User，如此在使用時可利用下例程式碼存取到userinfo的資料，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;User::with(&#39;userinfo&#39;)-&amp;gt;find(1)-&amp;gt;first();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若是沒有設定，也可以利用下利存取，但似乎就比較沒有彈性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;User::leftJoin(&#39;user_info as info&#39;)-&amp;gt;find(1).first();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;累了&amp;hellip;連laravel都沒紀錄完&amp;hellip;.下回再打&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>大搬家</title>
      <link>http://localhost:1313/post/other/da_ban_jia/</link>
      <pubDate>Sat, 09 Aug 2014 02:09:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/other/da_ban_jia/</guid>
      <description>&lt;p&gt;最近已經逐漸熟悉AWS的一些服務，決定要狠下心把家裡的Linux停掉。把一些東西都轉到雲端上，所以文章現在都存在&lt;code&gt;tumblr.&lt;/code&gt;上了。不然其實電費算起來也是挺貴的&amp;hellip;搬了兩個小時終於把文章都重新整理好了。手工搬實在累&amp;hellip;連DNS都要重新設定。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Phabricator 基本應用</title>
      <link>http://localhost:1313/post/cooperation/phabricator/phabricator_ji_ben_ying_yong/</link>
      <pubDate>Fri, 06 Jun 2014 23:36:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/cooperation/phabricator/phabricator_ji_ben_ying_yong/</guid>
      <description>

&lt;h2 id=&#34;create-maniphest:e921b76cadbcd20db381f231dd58b830&#34;&gt;Create Maniphest&lt;/h2&gt;

&lt;p&gt;在這可建立 &lt;code&gt;Task&lt;/code&gt; 指派給某一個人，目前發現最大的功用是當在 review code 的時候可以讓 commit 加入某一個 task。&lt;/p&gt;

&lt;h2 id=&#34;create-herald-rule:e921b76cadbcd20db381f231dd58b830&#34;&gt;Create Herald Rule&lt;/h2&gt;

&lt;p&gt;在 &lt;code&gt;Herald&lt;/code&gt; 的頁面 &lt;code&gt;Create Herald Rule&lt;/code&gt; 建立一條新規則&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Commits&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Commits 的規則是當 repositories 有提交程式碼的時候皆會通知&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Differential Revisions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Differential Revisions&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Maniphest Tasks&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Maniphest Tasks 的規則是當有建立或修改 task 皆會通知&lt;/p&gt;

&lt;h3 id=&#34;規則隸屬:e921b76cadbcd20db381f231dd58b830&#34;&gt;規則隸屬&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Personal&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;個人的規則&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Object&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;版本庫的規則&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Global&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;全域規則&lt;/p&gt;

&lt;h3 id=&#34;設定規則:e921b76cadbcd20db381f231dd58b830&#34;&gt;設定規則&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Personal&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Conditions&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;all of&lt;/code&gt; these conditions are met:
&lt;code&gt;Repository is any of test_repository&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;還在摸索中，所以就先通用只要是版本庫的 commit 都通知我&lt;/p&gt;

&lt;p&gt;Action&lt;/p&gt;

&lt;p&gt;Take these actions every time this rule matches:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Add me to CC&lt;/code&gt; : cc mail 通知我&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Send me an email&lt;/code&gt; : mail 通知我&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mark with flag&lt;/code&gt; : 建立 flag，還可以選顏色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Trigger an Audit by me&lt;/code&gt; : 通知我 review code&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Do nothing&lt;/code&gt; : 什麼都不做&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;** Maniphest Tasks**&lt;/p&gt;

&lt;p&gt;Conditions&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;all of&lt;/code&gt; these conditions are met:
&lt;code&gt;Assignee is any of alan&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;task 則是設定指派給我的都通知我&lt;/p&gt;

&lt;p&gt;Action&lt;/p&gt;

&lt;p&gt;Take these actions every time this rule matches:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Assign task to me&lt;/code&gt; : 指派給我自己&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只有這個規則比較不一樣。&lt;/p&gt;

&lt;h2 id=&#34;owners:e921b76cadbcd20db381f231dd58b830&#34;&gt;Owners&lt;/h2&gt;

&lt;p&gt;若覺得要設定一堆規則很麻煩，有發現另外一個比較簡單的&amp;hellip;&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;Owners&lt;/code&gt; 可以 &lt;code&gt;Create Package&lt;/code&gt; 在這邊選擇 &lt;code&gt;Repository&lt;/code&gt; 並設定 path。這樣當版本庫有異動的時候就都會通知。&lt;/p&gt;

&lt;h2 id=&#34;email-設定:e921b76cadbcd20db381f231dd58b830&#34;&gt;Email 設定&lt;/h2&gt;

&lt;p&gt;在 &lt;code&gt;Config&lt;/code&gt; 有兩個地方可以設定 email 一個是 &lt;code&gt;Mail&lt;/code&gt; 另一個是 &lt;code&gt;PHPMailer&lt;/code&gt; 就選擇比較簡單的設定即可，我自己設定兩個&amp;hellip;結果好像會發兩封信&amp;hellip;&lt;/p&gt;

&lt;p&gt;郵件伺服器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;phpmailer.mailer
Configure mailer used by PHPMailer.
Current Value: &amp;quot;smtp&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;郵件伺服器 domain&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;phpmailer.smtp-host
Host for SMTP.
Current Value: domain.com.tw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;郵件伺服器 port&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;phpmailer.smtp-port
Port for SMTP.
Current Value: 25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是否加密&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;phpmailer.smtp-protocol
Configure TLS or SSL for SMTP.
Current Value: null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;帳號&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;phpmailer.smtp-user
Username for SMTP.
Current Value: &amp;quot;root&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;密碼&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;phpmailer.smtp-password
Password for SMTP.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Phabricator 建置很久了這兩天才開始在學著用，覺得 &lt;a href=&#34;http://localhost:1313/post/94171590878/install-phabricator-and-run-on-the-gitlab&#34;&gt;Phabricator&lt;/a&gt; 對於 teamwork 的幫助不亞於 &lt;a href=&#34;http://localhost:1313/post/94170890773/github-gitlab&#34;&gt;Gitlab&lt;/a&gt; ，有時候在合併版本發生衝突的時候才開始在看為什麼會有衝突，總覺得很不爽。所以若能即時知道，團隊裡有誰做了甚麼樣的提交，相信對於開發中以及開發完的上線都會很有幫助。&lt;/p&gt;

&lt;p&gt;但是網路上的資訊有點少，要摸索清楚整個系統有點吃力，每一樣都要 &lt;code&gt;try error&lt;/code&gt;，文章寫起來也有點凌亂，不管了，慢慢整理吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>淺談我的Agile</title>
      <link>http://localhost:1313/post/agile/qian_tan_wo_de_agile/</link>
      <pubDate>Thu, 27 Mar 2014 12:18:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/agile/qian_tan_wo_de_agile/</guid>
      <description>

&lt;p&gt;在開頭先題外話一下，最近社會動蕩不安，老百姓對政府黑箱通過&lt;code&gt;兩岸服務貿易&lt;/code&gt;感到憤怒，我自己也挺生氣的，所以我決定響應&lt;code&gt;捍衛民主 退回服貿 3/30人民站出來！&lt;/code&gt;帶我兒子去&lt;del&gt;街頭&lt;/del&gt;曬曬太陽&lt;/p&gt;

&lt;p&gt;OK！宣泄完了進入正題。&lt;/p&gt;

&lt;p&gt;首先我先聲明往後我會持續學習&lt;code&gt;Scrum&lt;/code&gt;打算連載個7天7夜。請各位多多指教！！&lt;/p&gt;

&lt;h2 id=&#34;開始:b0a2a6a9dfda4cc4a8af1e07fb40a354&#34;&gt;開始&lt;/h2&gt;

&lt;p&gt;在當前公司導入敏捷開發也一陣子了，雖然執行的過程都很順利，同事也都依照技術長的方式作業。但我對於敏捷開發還是不甚了解，所以這開啟了我學習的動機。&lt;/p&gt;

&lt;p&gt;因為我個人比較&lt;del&gt;背骨&lt;/del&gt;好奇，對於別人講的我不會立刻盡信，但我也不會反駁，因為我覺得無論何事都必須要自己實事求事。於是乎我開始自己學習何謂敏捷開發。&lt;/p&gt;

&lt;p&gt;我們執行的是&lt;code&gt;Scrum&lt;/code&gt;，首先先說一下人員配置，我們分三種角色：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;專案經理 (Project Manager)&lt;/li&gt;
&lt;li&gt;主持人 (Scrum Master)&lt;/li&gt;
&lt;li&gt;工程師 (Developer)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;當專案開始啟動，我們會執行以下作業：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;進行需求訪談 (RA)&lt;/li&gt;
&lt;li&gt;啟動專案 Product Backlog&lt;/li&gt;
&lt;li&gt;&lt;del&gt;痛苦的&lt;/del&gt;Planning meeting&lt;/li&gt;
&lt;li&gt;分配 Sprint&lt;/li&gt;
&lt;li&gt;開始 Coding&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我今天參加了&lt;a href=&#34;https://www.facebook.com/groups/179345672472/&#34;&gt;Scrum Community in Taiwan&lt;/a&gt;的分享會，學習別人導入的經驗，除了學習，也檢討當前雖然執行也是很順利，但似乎還可以再加強什麼，因為我們並沒有落實我所理解的敏捷開發的精神。以下是我們沒執行的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Planning poker&lt;/li&gt;
&lt;li&gt;Standup meeting&lt;/li&gt;
&lt;li&gt;Sprint demo&lt;/li&gt;
&lt;li&gt;Sprint retrospective meeting&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;這些我們都沒有做。好吧~ 或許是技術長不想浪費成本，覺得這些根本沒時間做，但我覺得有些對開發者是有幫助的，就讓我逐條表達一些意見。&lt;/p&gt;

&lt;h3 id=&#34;plannging-poker:b0a2a6a9dfda4cc4a8af1e07fb40a354&#34;&gt;Plannging poker&lt;/h3&gt;

&lt;p&gt;其實工程師是很害怕預估工時的，我也不例外，因為預估的工時往往都需要&lt;code&gt;*3&lt;/code&gt;倍才較精準，這是為什麼呢？這是因為開發的過程當中，會有一些不可預知的因素在干擾著開發者，無論是需求變更，或是架構變更。都會影響思緒進而可能延宕時間。再說&amp;hellip;工程師總是擔心受怕不曉得在哪裡會遇到麻煩，所以以墨菲定律來說，&lt;code&gt;你覺得可能會發生錯誤的地方，那就一定會發生&lt;/code&gt;。若是每次在領 Task 的時候都能執行 Plannging poker 我相信對開發者是很有幫助的。&lt;/p&gt;

&lt;h3 id=&#34;standup-meeting:b0a2a6a9dfda4cc4a8af1e07fb40a354&#34;&gt;Standup meeting&lt;/h3&gt;

&lt;p&gt;對於每天早晨工作前15分鐘的站立會議，我對這可能就比較無感。因為我做事情的方式是屬於分散做，那邊完成一點這邊完成一點，最後再整個兜起來。但若是遇到做一做之後架構需要變更，那這個會議就相當有功效了。可以在會議後各別討論，不讓問題延宕過久拖到 Sprint 結束的時間。&lt;/p&gt;

&lt;h3 id=&#34;sprint-demo:b0a2a6a9dfda4cc4a8af1e07fb40a354&#34;&gt;Sprint demo&lt;/h3&gt;

&lt;p&gt;通常我們交出去就交出去了&amp;hellip;所以也不會有所謂的專案經理來向我們展示成果，這樣當然就不會有回饋，以至於下次開發專案經理才提說上次怎樣怎樣，所以這次做要避免什麼什麼，若是能有成果展示，當下向我們建議一些他認為哪裡做的不夠完售，工程師也比較不會錯愕。或是可以鼓勵工程師哪裡做得很棒，甚至在客戶沒想到的情況下我們已經幫他們想到了。&lt;/p&gt;

&lt;h3 id=&#34;sprint-retrospective-meeting:b0a2a6a9dfda4cc4a8af1e07fb40a354&#34;&gt;Sprint retrospective meeting&lt;/h3&gt;

&lt;p&gt;我個人覺得這相當重要！！但我們卻沒做，我常常在做完專案的時候，會有一些建議想要講，若是沒有特別開這個回顧會議，要我直接跟技術長提也是超奇怪的。這應該算是一種管道，畢竟執行面是在工程師，SA 有時候設想的並不周延，甚至 SD 分析錯誤，造成工程師執行困難。&lt;/p&gt;

&lt;p&gt;最後我們也沒有做 TDD + PP 我個人是蠻想嘗試 Pair programming，我想知道這會擦出什麼樣的火花。&lt;/p&gt;

&lt;p&gt;總而言之，敏捷開發並不是說每一項都要執行，應該是挑適合團隊的工作文化與工作方式，這樣才不會造成反彈或是排斥，以上若有錯誤請直接糾正，因為我還沒深入了解！！想透過撰寫督促自己學習。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Injection Principle Design Pattern</title>
      <link>http://localhost:1313/post/ooad/injection_principle_design_pattern/</link>
      <pubDate>Wed, 26 Feb 2014 21:33:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/ooad/injection_principle_design_pattern/</guid>
      <description>

&lt;p&gt;這兩天有個案例，內容簡約來說可以這樣闡述：&lt;/p&gt;

&lt;h3 id=&#34;a客戶要簽約買限額的n種廣告-要提供api介接:adec025e9f0507beb57a8d7d7ddd0091&#34;&gt;A客戶要簽約買限額的N種廣告，要提供API介接&lt;/h3&gt;

&lt;p&gt;所以我開始分解上面這段話做設計。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;這次A客戶簽約，下次也有機會與B客戶簽約。&lt;/li&gt;
&lt;li&gt;廣告有 Header, Body, Footer, Left 及 Right 共5個區域可以放產品，A客戶要買 Header, Body 以及 Right 三種，當然下次別人也有機會買 Footer 或是 Left。&lt;/li&gt;
&lt;li&gt;A客戶各買 100個, 100個 和 250個產品限額的廣告方案，當然別的客戶也有可能更多亦或更少。&lt;/li&gt;
&lt;li&gt;A客戶使用的介接格式是 &lt;a href=&#34;http://zh.wikipedia.org/zh-tw/XML&#34;&gt;XML&lt;/a&gt;，當然也有機會用到 &lt;a href=&#34;http://www.json.org/&#34;&gt;Json&lt;/a&gt; 或其他種類的資料格式，輸出也是相同。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;若是不考慮 Design Pattern 其實這樣子的介接不難做，但要思考的是，假使不做適當的邏輯分離與切割，造成高耦合度，那擴充與修改是否會造成災難。所以我一直覺得寫程式人人都會，但是寫的一手好程式可就不簡單了。而我一直朝著這個目標邁進。&lt;/p&gt;

&lt;p&gt;當分析需求完畢，我就開始發想，有哪種設計模式或原則適合這種狀況，應該要避免太複雜的設計模式造成開發困難或結構複雜化。小弟不才，懂得不多。我想到用 Injection Principle 這個原則來做。&lt;/p&gt;

&lt;h2 id=&#34;介接資料:adec025e9f0507beb57a8d7d7ddd0091&#34;&gt;介接資料&lt;/h2&gt;

&lt;p&gt;與A客戶協議好用XML資料格式介接，如之前提到的，介接的資料格式是有機會異動的，所以我覺得解析與回傳資料是應該要被分離的。&lt;/p&gt;

&lt;p&gt;只要是介接都必須要有解析與回傳，所以我定義介接資料用的介面，裡面必須要實作解析與輸出這兩件事。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 解析、回傳介接資料介面
 */
interface ApiAdParseInterface {

  /**
   * 任何解析廣告的資料都必須實作
   * @param type $content
   */
  public function parse($content);

  /**
   * 任何回傳廣告的介接結果都必須實作
   * @param type $content
   */
  public function generate($content);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我想到日後或許A客戶也有機會異動介接資料的格式，所以我選擇用&lt;a href=&#34;https://en.wikipedia.org/wiki/Dependency_injection&#34;&gt;DI&lt;/a&gt;處理，制訂出配置器加強彈性。&lt;/p&gt;

&lt;p&gt;這個配置器主要提供注入的方法，今天若是要實作XML的資料格式，那就在建立這個實體的時候提供 instance。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 解析、回傳介接結果配置器
 */
class ApiParseAdAdapter {

  private $adapter;

  public function ApiParseAdAdapter($adapter) {
    $this-&amp;gt;adapter = $adapter;
  }

  /**
   * 解析輸入的資料
   * @param type $content
   */
  public function parse($content) {
    return $this-&amp;gt;adapter-&amp;gt;parse($content);
  }

  /**
   * 輸出要產生的資料格式
   * @param type $content
   */
  public function generate($content) {
    return $this-&amp;gt;adapter-&amp;gt;generate($content);
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;實作以 XML 格式介接新增廣告&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 實作解析、生成新增廣告xml資料
 */
class ParseAddAdXml implements ApiAdParseInterface {

  public function parse($xml) {
    ...
    return $items;
  }

  public function generate($content) {
    ...
    return $xml;
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以後若是要改用 Json 那就建立 &lt;code&gt;ParseAddAdJson&lt;/code&gt; 就可以了不用動到其他的程式，相對的安全很多。&lt;/p&gt;

&lt;h2 id=&#34;處理合約:adec025e9f0507beb57a8d7d7ddd0091&#34;&gt;處理合約&lt;/h2&gt;

&lt;p&gt;今天是與A客戶簽約，而下次是與B客戶簽約。每份合約各自表述，除了限額與廣告種類，客戶都必須要新增廣告，也都要解析客戶丟過來的資料，以及回傳處理結果。所以我定義了合約的抽象類別，只要是合約都必須要實作解析資料，新增廣告，輸出結果。而為了統一外部的呼叫，則有共用的執行合約方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 統一的合約執行流程
 */
abstract class PlanBaseAbstract {

    public function execPlan($xml) {
        $items = $this-&amp;gt;parse($xml);
        $content = $this-&amp;gt;addAd($items);
        return $this-&amp;gt;generate($content);
    }

    abstract protected function addAd($items) ;

    abstract protected function parse($content) ;

    abstract protected function generate($content) ;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再來是處理A客戶的合約內容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * A客戶的新增廣告內容
 */
class ACustomerPlan extends PlanBaseAbstract {

    public function addAd($items)
        ...
        在這邊新增各種廣告
        ...
    }

    /**
     * 使用 DI 解析介接資料
     */
    public function parse($content) {
        $mgr = new ApiParseAdapterMgr(new ParseAddAdXmlMgr());
        $items = $mgr-&amp;gt;parse($content);
        ...
        return $items;
    }

    /**
     * 使用 DI 輸出介接結果
     */
    public function generate($content) {
        ...
        $mgr = new ApiParseAdapterMgr(new ParseAddAdXmlMgr());
        return $mgr-&amp;gt;generate($result);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;廣告物件:adec025e9f0507beb57a8d7d7ddd0091&#34;&gt;廣告物件&lt;/h2&gt;

&lt;p&gt;每個廣告都有新增及取得當前數量兩件事，這裡也定義一個介面供各種廣告實作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 廣告處理介面
 */
interface AdInterface {

    /**
     * 新增廣告
     */
    public function add() ;

    /**
     * 當前廣告數量
     */
    public function getCount() ;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;實作廣告的過程中或許有其他的事情要做所以可以寫在各自的廣告物件。這裡就新增一個 Header 當作記錄。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 實作 Header 廣告
 */
class Header implements AdInterface {

    /**
     * 新增廣告實作
     */
    public function add() {
        ...
    }

    /**
     * 取得當前廣告數量實作
     */
    public function getCount() {
        ...
        return (int) $count;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;未來只要各自實作 Body, Footer 就可以了。這樣也有做到 OCP (開放封閉原則)。&lt;/p&gt;

&lt;p&gt;最後用 Class Diagram 解釋這整個關係。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/post/ooad/injection_principle_design_pattern/Class_Diagram.png&#34; alt=&#34;Class Diagram&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Phabricator review code應用</title>
      <link>http://localhost:1313/post/cooperation/phabricator/phabricator_review_codeying_yong/</link>
      <pubDate>Thu, 23 Jan 2014 14:01:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/cooperation/phabricator/phabricator_review_codeying_yong/</guid>
      <description>

&lt;h2 id=&#34;review-code-前置設定:23ce2a5d00bbdd1941d3d8135a4e9cc0&#34;&gt;Review code 前置設定&lt;/h2&gt;

&lt;p&gt;在 Config &amp;gt; Diffusion 設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;diffusion.ssh-port  &amp;quot;your ssh port&amp;quot;
diffusion.ssh-user  &amp;quot;your username&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或是 command line 執行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /path/to/phabricator
$ ./bin/config set diffusion.ssh-user &amp;quot;your username&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Config &amp;gt; Daemon &amp;gt; sphd.user 設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;phd.user    &amp;quot;your username&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或是 command line 執行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./bin/config set phd.user &amp;quot;your username&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要注意的就是 Config &amp;gt; Conduit &amp;gt; conduit.servers 是否有設定，我是預設留空的。&lt;/p&gt;

&lt;h2 id=&#34;create-repository:23ce2a5d00bbdd1941d3d8135a4e9cc0&#34;&gt;Create Repository&lt;/h2&gt;

&lt;p&gt;因為有新版的 Repository 設定，所以&lt;a href=&#34;http://localhost:1313/post/94171590878/install-phabricator-and-run-on-the-gitlab&#34;&gt;舊版&lt;/a&gt;的已經不適用，新版的設定中有更清楚的設置流程了。&lt;/p&gt;

&lt;p&gt;按下 Create Repository 開始建立需要 Review 的版本庫。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Repository Type 選擇使用的版本控制系統。&lt;/li&gt;
&lt;li&gt;Repository Name and Location 輸入人類看的懂的標題，以及版本控制 &lt;code&gt;Callsign&lt;/code&gt; ，官網的範例是取專案第一個字母，必須要為大寫。譬如專案名字是 &lt;code&gt;Test&lt;/code&gt; 那 &lt;code&gt;Callsign&lt;/code&gt; 就是 &lt;code&gt;T&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Policies 選擇可以控制這個版本庫的群組、會員。&lt;/li&gt;
&lt;li&gt;Repository Ready! 開始建立新的版本庫，或是略過直接到設定檔設定。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;我都是到第四步之後直接選 &lt;code&gt;Configure More Options First&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;這邊有兩種方式，可以提供 review 的服務，一是用 Phabricator 自帶的 &lt;code&gt;Host Repository on Phabricator&lt;/code&gt;，可以參考&lt;a href=&#34;http://www.phabricator.com/docs/phabricator/article/Diffusion_User_Guide_Repository_Hosting.html&#34;&gt;官網設定&lt;/a&gt;，這個服務是方便自動 merge，push。但是當我完成官網上的設定後，提交 review code 的請求在驗證 ssh 會出問題，導致一直無法自動 push，無法收到需要 review 的請求，所以後來放棄，改用 &lt;code&gt;Host Repository Elsewhere&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;當 &lt;code&gt;Host Repository Elsewhere&lt;/code&gt; 的設定都完成了，接著設定 &lt;code&gt;Remote&lt;/code&gt; ，Remote URI 選擇版本庫位置，當然也可以用 Github 上的，Credential 則是看使用的是哪一種方式，若是用 &lt;code&gt;git@&lt;/code&gt; 那就必須要增加 private key，若是用 &lt;code&gt;http&lt;/code&gt; 那就必須要增加 password 的驗證方式。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Local&lt;/code&gt; 則是放置 repo 的地方，&lt;code&gt;Branches&lt;/code&gt; 選擇預設 track 的分支、或是只 track 哪一個分支，最後是 Autoclose Only，這個設定要相當小心，因為當提交 Review 通過後，會自動關閉分支。可在 &lt;code&gt;Actions&lt;/code&gt; 中關閉。&lt;/p&gt;

&lt;p&gt;這些設定都完成後就可以啟動 Daemons, 因為這很常使用所以我寫了一隻 shell script
放在 &lt;code&gt;.bashrc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim ~/.bashrc
# Phabricator service
function phb(){
        if [ &amp;quot;$1&amp;quot; == &amp;quot;home&amp;quot; ]; then
                cd /path/to/phabricator/
        elif [ &amp;quot;$1&amp;quot; == &amp;quot;start&amp;quot; ]; then
                /path/to/phabricator/bin/phd start
        elif [ &amp;quot;$1&amp;quot; == &amp;quot;stop&amp;quot; ]; then
                /path/to/phabricator/bin/phd stop
        elif [ &amp;quot;$1&amp;quot; == &amp;quot;restart&amp;quot; ]; then
                /path/to/phabricator/bin/phd restart
        elif [ &amp;quot;$1&amp;quot; == &amp;quot;edit&amp;quot; ]; then
                rm -rf /path/to/phabricator/local/$2
                /path/to/phabricator/bin/repository edit $2 --as webuser --local-path $3
        elif [ &amp;quot;$1&amp;quot; == &amp;quot;delete&amp;quot; ]; then
                rm -rf /path/to/phabricator/local/$2
                /path/to/phabricator/bin/repository delete $2
        fi
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這樣就可以用 &lt;code&gt;phb start&lt;/code&gt; 啟動了。&lt;/p&gt;

&lt;h2 id=&#34;設置-arcanist:23ce2a5d00bbdd1941d3d8135a4e9cc0&#34;&gt;設置 Arcanist&lt;/h2&gt;

&lt;p&gt;在官網的&lt;a href=&#34;http://www.phabricator.com/docs/phabricator/article/Arcanist_User_Guide.html&#34;&gt;設置教學&lt;/a&gt;很簡單易懂，安裝完也必須設定變數：&lt;/p&gt;

&lt;p&gt;在 Linux 上需要設定 &lt;code&gt;EDITOR&lt;/code&gt; 及 &lt;code&gt;arcanist&lt;/code&gt; 的路徑環境變數。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim ~/.bashrc
export PATH=&amp;quot;$PATH:/path/to/phabricator/arcanist/bin/&amp;quot;
export EDITOR=$(which vim)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Windows 上需要設定 &lt;code&gt;core.editor&lt;/code&gt; 及 &lt;code&gt;arcanist&lt;/code&gt; 的路徑環境變數。&lt;/p&gt;

&lt;p&gt;打開 cmd.exe 輸入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config --global core.editor &amp;quot;C:\Windows\notepad.exe&amp;quot; fileeditor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就會在 &lt;code&gt;.gitconfig&lt;/code&gt; 產生&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;editor = C:\\Windows\\notepad.exe fileeditor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下來就可以開始提交 review 請求&lt;/p&gt;

&lt;h2 id=&#34;提交程式碼:23ce2a5d00bbdd1941d3d8135a4e9cc0&#34;&gt;提交程式碼&lt;/h2&gt;

&lt;p&gt;在這邊記錄以 Linux 的方式提交，試著執行 arc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arc
Usage Exception: No command provided. Try &#39;arc help&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若出現這個錯誤訊息，表示 &lt;code&gt;arc&lt;/code&gt; 已經設定成功。&lt;/p&gt;

&lt;p&gt;檢查當前檔案狀態&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit -a
# On branch master
# Untracked files:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)
#
#       alan_test.txt
nothing added to commit but untracked files present (use &amp;quot;git add&amp;quot; to track)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把 alan_test.txt 提交 review，從原本的 &lt;code&gt;git add&lt;/code&gt; 改執行 &lt;code&gt;arc diff&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arc diff
Usage Exception: YOU NEED TO INSTALL A CERTIFICATE TO LOGIN TO PHABRICATOR

You are trying to connect to &#39;http://phabricator.example.tw/api/&#39; but do not have a certificate installed for this host. Run:

      $ arc install-certificate

...to install one.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;會發生錯誤是因為尚未設定 &lt;code&gt;certificate&lt;/code&gt; 系統通知該做什麼設定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arc install-certificate
Installing certificate for &#39;http://phabricator.example.tw/api/&#39;...
Trying to connect to server...
Connection OK!

LOGIN TO PHABRICATOR
Open this page in your browser and login to Phabricator if necessary:

    http://phabricator.example.tw/conduit/token/

Then paste the token on that page below.

    Paste token from that page:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打開瀏覽器訪問 &lt;code&gt;http://phabricator.example.tw/conduit/token/&lt;/code&gt;，並且登入要連結  Phabricator 上的 user。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/post/cooperation/phabricator/phabricator_review_codeying_yong/arc-certificate.png&#34; alt=&#34;arc-certificate&#34; /&gt;&lt;/p&gt;

&lt;p&gt;取得 &lt;code&gt;Token&lt;/code&gt;，並且輸入上一步驟的設定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Installing certificate for &#39;http://phabricator.example.tw/api/&#39;...
Trying to connect to server...
Connection OK!

LOGIN TO PHABRICATOR
Open this page in your browser and login to Phabricator if necessary:

    http://phabricator.example.tw/conduit/token/

Then paste the token on that page below.

    Paste token from that page: dbl2l5kvjiefbhv2ex--------jsi2idmiktnkswr

Downloading authentication certificate...
Installing certificate for &#39;alan&#39;...
Writing ~/.arcrc...
 SUCCESS!  Certificate installed.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;設定成功，打開 &lt;code&gt;.arcrc&lt;/code&gt; 就會發現設定是 Phabricator 的 user。&lt;/p&gt;

&lt;p&gt;再次執行提交&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arc diff
You have untracked files in this working copy.

  Working copy: /home/alan/test/

  Untracked files in working copy:
    alan_test.txt

Since you don&#39;t have &#39;.gitignore&#39; rules for these files and have not listed
them in &#39;.git/info/exclude&#39;, you may have forgotten to &#39;git add&#39; them to your
commit.


Do you want to add this file to the commit? [y/N] y



Enter commit message: alan arc test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下來會跳轉到輸入詳細的資訊&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alan arc test

Summary: my first test

Test Plan: none

Reviewers: webuser

CC:

# Tip: Use &amp;quot;Fixes T123&amp;quot; in your summary to mark that the current revision
# completes a given task.

# NEW DIFFERENTIAL REVISION
# Describe the changes in this new revision.
#
# Included commits in branch master:
#
#         5780b5046d43 alan arc test
#
# arc could not identify any existing revision in your working copy.
# If you intended to update an existing revision, use:
#
#   $ arc diff --update &amp;lt;revision&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;:wq&lt;/code&gt; 儲存後離開會開始提交&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Linting...
No lint engine configured for this project.
Running unit tests...
No unit test engine is configured for this project.
Updating commit message...
Created a new Differential revision:
        Revision URI: http://phabricator.example.tw/D21

Included changes:
  A       alan_test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這邊個資訊是在告知提交的資訊中沒有交代要 test，及 review 版號是 &lt;code&gt;D21&lt;/code&gt; 包含改變的檔案清單，這樣就完成了 client 的提交。因為在 &lt;code&gt;Reviewers:&lt;/code&gt; 填寫的是 webuser，所以他會收到通知。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/post/cooperation/phabricator/phabricator_review_codeying_yong/arc-5.png&#34; alt=&#34;arc-notify&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接下來就可以看到詳細的資料，alan 改變了檔案提交了程式碼，webuser 需要透過介面完成審核。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/post/cooperation/phabricator/phabricator_review_codeying_yong/arc-6.png&#34; alt=&#34;arc-review&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/post/cooperation/phabricator/phabricator_review_codeying_yong/arc-7.png&#34; alt=&#34;arc-accpet&#34; /&gt;&lt;/p&gt;

&lt;p&gt;當 webuser 完成了審核，同意了。alan 也會收到通過的通知。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/post/cooperation/phabricator/phabricator_review_codeying_yong/arc-8.png&#34; alt=&#34;arc-review-ok&#34; /&gt;&lt;/p&gt;

&lt;p&gt;alan 也可以看到詳細的資訊。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/post/cooperation/phabricator/phabricator_review_codeying_yong/arc-9.png&#34; alt=&#34;arc-review-ok-info&#34; /&gt;&lt;/p&gt;

&lt;p&gt;這時候就可以把改變的檔案 push 上版本庫，若是按正常流程要 &lt;code&gt;git add&lt;/code&gt;, &lt;code&gt;git commit&lt;/code&gt;，但是在這邊只需要執行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arc amend
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arc land &#39;branch name&#39; D版號
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;amend&lt;/code&gt; 是提交全部已經通過審核的版本，而 &lt;code&gt;land&lt;/code&gt; 則可以單獨指定，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arc amend
Amending commit message to reflect revision D21: alan arc test.
Closing revision D21 &#39;alan arc test&#39;...
You may now push this commit upstream, as appropriate (e.g. with &#39;git push&#39;,
or &#39;git svn dcommit&#39;, or by printing and faxing it).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;系統通知完成 &lt;code&gt;D21&lt;/code&gt; 的提交，並且要自己執行 &lt;code&gt;git push&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push
Counting objects: 4, done.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 373 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
To git@git.ocomm.com.tw:home/test.git
   1d4af3f..d885ebb  master -&amp;gt; master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若是沒在網站介面審核通過就直接執行 &lt;code&gt;arc diff&lt;/code&gt; 會有提示訊息出縣，要求先通過審核。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arc diff
Amending commit message to reflect revision.
Done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這樣就完成囉!! 回到網站介面可以發現，版本庫中已經完成一次提交。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/post/cooperation/phabricator/phabricator_review_codeying_yong/arc-down.png&#34; alt=&#34;arc-down&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>